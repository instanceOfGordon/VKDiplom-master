using System.Collections; using System.Collections.Generic; using System.ComponentModel; using System.Threading; using System.Windows.Graphics; using HermiteInterpolation.Shapes; using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics;   namespace VKDiplom.Engine {     /// <summary>     ///     Defines entire world.     /// </summary>     public class Scene : IList<IDrawable>     {         public enum LightingQuality         {             //[Display(Name = "Software Engineer")]             //[Description("Software engineer responsible for core development.")]             Low,             Medium,             High,         }          // Avoid allocating in Draw method as it is called each frame.         private static readonly Color BackgroundColor = new Color(244, 244, 240, 255);          // List of every shape in scene.         // Rotation matrix for z-axe facing up.         private readonly Matrix _zAxeFacingUpRotation = Matrix.CreateRotationZ(MathHelper.ToRadians(-135))*                                                         Matrix.CreateRotationX(MathHelper.ToRadians(-90));          // Coordinate axes         private CoordinateAxes _axes;         // Shader used for rendering         private BasicEffect _effect;          private Matrix _scale = Matrix.CreateScale(1.0f);         private float _zoom = 1.0f;           public Scene()         {             Camera = new Camera();             InitializeComponent();         }          public Scene(Camera camera)         {             Camera = camera;             InitializeComponent();         }          public float RotationX { get; set; }          public float RotationY { get; set; }         public float RotationZ { get; set; }  //        public void Rotation(Vector3 axis, float angle) //        { //            _rotationAxis = axis; //            _rotationAngle = angle; //        } // //        public void DefaultRotation() //        { //            _rotationAxis = Vector3.One; //            _rotationAngle = 0; //        }          public Camera Camera { get; }  //        public List<IDrawable> Shapes //        { //            get { return _shapes; } //        }          public Vector3 Position { get; set; } = Vector3.Up;          public float Zoom         {             get { return _zoom; }             set             {                 _zoom = value;                 _scale = Matrix.CreateScale(_zoom);             }         }          // Use advanced lighting when HW supports it.         public bool PreferPerPixelLighting         {             set { _effect.PreferPerPixelLighting = value; }         }          private List<IDrawable> _shapes = new List<IDrawable>();           private void InitializeComponent()         {             RotationX = 0.0f;             RotationY = 0.0f;             RotationZ = 0.0f;             _axes = new CoordinateAxes();             _effect = new BasicEffect(GraphicsDeviceManager.Current.GraphicsDevice)             {                 VertexColorEnabled = true,             };             SetLighting(LightingQuality.High);             PreferPerPixelLighting = true;         }          /// <summary>         ///     Sets level of lighting. Higher values may decrease performance.         /// </summary>         /// <param name="quality">         ///     Low: Basic static lighting         ///     Medium: Dynamic lighting using one source of light.         ///     High: Dynamic using three sources of light.         /// </param>         public void SetLighting(LightingQuality quality)         {             switch (quality)             {                 case LightingQuality.Low:                     LowQualityLighting();                     break;                 case LightingQuality.Medium:                     MediumQualityLighting();                     break;                 case LightingQuality.High:                     HighQualityLighting();                     break;             }         }          private void LowQualityLighting()         {             _effect.LightingEnabled = false;             _effect.AmbientLightColor = new Vector3(0.8f, 0.8f, 0.8f);             //_effect.EmissiveColor = new Vector3(0.5f, 0.4f, 0.5f);         }          private void MediumQualityLighting()         {             //_effect.EnableDefaultLighting();             _effect.LightingEnabled = true;             // Enable one directional light.             _effect.DirectionalLight0.Enabled = true;             // A light...             _effect.DirectionalLight0.DiffuseColor = new Vector3(0.97f, 0.97f, 0.93f);             // ... coming from...             _effect.DirectionalLight0.Direction = Vector3.Normalize(new Vector3(1, -1.5f, 0));             // ... with this highlight             _effect.DirectionalLight0.SpecularColor = new Vector3(0.8f, 0.8f, 0.8f);             // Ambient color (i.e light coming from all directions)             _effect.AmbientLightColor = new Vector3(0.6f, 0.6f, 0.6f);             // Emissive color of objects (i.e. light emited from all objects)             //_effect.EmissiveColor = new Vector3(0.5f, 0.4f, 0.5f);         }          private void HighQualityLighting()         {             //_effect.EnableDefaultLighting();             _effect.LightingEnabled = true;             // Enable three light sources.             _effect.DirectionalLight0.Enabled = true;             _effect.DirectionalLight1.Enabled = true;             _effect.DirectionalLight2.Enabled = true;                           // A lights...              // (Key light)             _effect.DirectionalLight0.DiffuseColor = new Vector3(0.92f, 0.92f, 0.92f);             // (Fill light)             _effect.DirectionalLight1.DiffuseColor = new Vector3(0.32f, 0.32f, 0.32f);             // (Rim light)             _effect.DirectionalLight2.DiffuseColor = new Vector3(0.9f, 0.9f, 0.9f);               // ... comings from...             _effect.DirectionalLight0.Direction = Vector3.Normalize(new Vector3(1, -1.5f, 0));             _effect.DirectionalLight1.Direction = Vector3.Normalize(new Vector3(-1, -1.5f, -1));             _effect.DirectionalLight2.Direction = Vector3.Normalize(new Vector3(0, -1.5f, 1));               // ... with this highlights             _effect.DirectionalLight0.SpecularColor = new Vector3(0.1f, 0.1f, 0.1f);             _effect.DirectionalLight0.SpecularColor = new Vector3(0.05f, 0.05f, 0.05f);             _effect.DirectionalLight0.SpecularColor = new Vector3(0.09f, 0.08f, 0.08f);             // Ambient color (i.e light coming from all directions)             _effect.AmbientLightColor = new Vector3(0.5f, 0.5f, 0.5f);             // Emissive color of objects (i.e. light emited from all objects)             //_effect.EmissiveColor = new Vector3(0.5f, 0.4f, 0.5f);         }          public void Draw()         {                         var graphicsDevice = GraphicsDeviceManager.Current.GraphicsDevice;             // clear the existing render target             graphicsDevice.Clear(ClearOptions.Target | ClearOptions.DepthBuffer, BackgroundColor, 1.0f, 0);              if (!_isAccessible) return;             //Define render world, view and projection.             _effect.World = _scale                 //*Matrix.CreateFromYawPitchRoll(.01f*RotationY, .01f*RotationX, .01f*RotationZ)                             *Matrix.CreateRotationZ(MathHelper.ToRadians(RotationZ))                             *Matrix.CreateRotationY(MathHelper.ToRadians(RotationY))                             *Matrix.CreateRotationX(MathHelper.ToRadians(RotationX))                            // *Matrix.CreateFromAxisAngle(_rotationAxis, _rotationAngle)                             //* Matrix.CreateTranslation(-1,-1,0)                             //*Matrix.CreateTranslation(_position)                             *_zAxeFacingUpRotation;             _effect.View = Camera.ViewTransform;             _effect.Projection = Camera.Projection;             //_effect.Alpha = 0.5f;            //graphicsDevice.BlendState = BlendState.AlphaBlend;             // Apply all shader rendering passes.             var effectTechniquePasses = _effect.CurrentTechnique.Passes;             graphicsDevice.BlendState = BlendState.AlphaBlend;             for (var i = 0; i < effectTechniquePasses.Count; i++)             {
                //effectTechniquePasses[i].Apply();
                //for (var j = 0; j < Shapes.Count; j++)
                //{
                //    if (j < Shapes.Count-1)
                //    {
                //        _effect.Alpha = 0.5f;
                //        //graphicsDevice.BlendState = BlendState.Opaque;                   
                //    }
                //    else
                //    {
                //        _effect.Alpha = 1f;

                //    }
                //    effectTechniquePasses[i].Apply();
                //    Shapes[j].Draw();
                //}
                //for (var j = _shapes.Count - 1; j >= 0; j--)                 //{                 //    _effect.Alpha = j < _shapes.Count - 1 ? 0.4f : 0.95f;                 //    effectTechniquePasses[i].Apply();                 //    _shapes[j].Draw();                 //}                 if (_shapes.Count > 0)                 {                    _effect.Alpha = 1f;                 //graphicsDevice.BlendState = BlendState.Opaque;                 effectTechniquePasses[i].Apply();                 _axes.Draw();                     for (var j = 0; j < _shapes.Count - 1; j++)                     {                         _effect.Alpha = 0.4f;                         effectTechniquePasses[i].Apply();                         _shapes[j].Draw();                     }
                    _effect.Alpha = 0.95f;                     effectTechniquePasses[i].Apply();                     _shapes[_shapes.Count - 1].Draw();                 }                                              }                                   }

        //public IEnumerable<IDrawable> Shapes()
        //{
        //    return _shapes;
        //}

        //public IEnumerable<IDrawable> this[int i]
        //{
        //    get { yield return _shapes[i]; }
        //}

        public IEnumerator<IDrawable> GetEnumerator()         {             return _shapes.GetEnumerator();         }          IEnumerator IEnumerable.GetEnumerator()         {             return GetEnumerator();         }          public void Add(IDrawable item)         {             _shapes.Add(item);         }          private bool _isAccessible = true;           public void Clear()         {             _isAccessible = false;
            //_shapes.Clear();
            Thread.Sleep(50);
            _shapes = new List<IDrawable>();             _isAccessible = true;         }          public bool Contains(IDrawable item)         {             return _shapes.Contains(item);         }          public void CopyTo(IDrawable[] array, int arrayIndex)         {             _shapes.CopyTo(array, arrayIndex);         }          public bool Remove(IDrawable item)         {             return _shapes.Remove(item);         }          public int Count => _shapes.Count;         public bool IsReadOnly => false;         public int IndexOf(IDrawable item)         {             return _shapes.IndexOf(item);         }          public void Insert(int index, IDrawable item)         {            _shapes.Insert(index,item);         }          public void RemoveAt(int index)         {             _shapes.RemoveAt(index);         }          public IDrawable this[int index]         {             get { return _shapes[index]; }             set { _shapes[index] = value; }         }     } }